<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mitosis Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Mitosis is a Rust library and a command line tool to run distributed platforms for transport research.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="guide/installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="guide/coordinator.html"><strong aria-hidden="true">2.</strong> Running a Coordinator</a></li><li class="chapter-item expanded "><a href="guide/worker.html"><strong aria-hidden="true">3.</strong> Running a Worker</a></li><li class="chapter-item expanded "><a href="guide/client.html"><strong aria-hidden="true">4.</strong> Running a Client</a></li><li class="chapter-item expanded "><a href="guide/manager.html"><strong aria-hidden="true">5.</strong> Managing multiple Workers</a></li><li class="chapter-item expanded "><a href="guide/architecture.html"><strong aria-hidden="true">6.</strong> Architecture Overview</a></li><li class="chapter-item expanded "><a href="guide/troubleshooting.html"><strong aria-hidden="true">7.</strong> Troubleshooting</a></li><li class="chapter-item expanded affix "><li class="part-title">Developer Guide</li><li class="chapter-item expanded "><a href="guide/development.html"><strong aria-hidden="true">8.</strong> Development Setup</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="client/sdk.html"><strong aria-hidden="true">9.</strong> Client SDK</a></li><li class="chapter-item expanded "><a href="http/index.html"><strong aria-hidden="true">10.</strong> HTTP endpoints</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Mitosis Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/stack-rs/mitosis/tree/master/guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Mitosis</strong> is a Rust library and a command line tool to run distributed platforms for transport research.</p>
<p>This guide is an example of how to use Mitosis to run a simple distributed platform to parallelize your tasks.
It is designed for transport-layer research, but it can be used for any other purpose.</p>
<h2 id="basic-workflow"><a class="header" href="#basic-workflow">Basic Workflow</a></h2>
<p>The Mitosis CLI tool is a single binary that provides subcommands for starting the Coordinator, Worker and Client processes.</p>
<p>Users function as units for access control, while groups operate as units for tangible resource control.
Every user has an identically named group but also has the option to create or join additional groups.</p>
<p>Users can delegate tasks to various groups via the Client, which are then delivered to the Coordinator and subsequently executed by the corresponding Worker.
Each Worker can be configured to permit specific groups and carry tags to denote its characteristics.</p>
<p>Tasks, once submitted, are distributed to different Workers based on their groups and tags. Every task is assigned a unique UUID, allowing users to track the status and results of their tasks.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Mitosis is free and open source. You can find the source code on
<a href="https://github.com/stack-rs/mitosis">GitHub</a> and issues and feature requests can be posted on
the <a href="https://github.com/stack-rs/mitosis/issues">GitHub issue tracker</a>. Mitosis relies on the community to fix bugs and
add features: if you'd like to contribute, please read
the <a href="https://github.com/stack-rs/mitosis/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> guide and consider opening
a <a href="https://github.com/stack-rs/mitosis/pulls">pull request</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>The Mitosis project contains a CLI tool (named <code>mito</code>) that you can use to directly start a distributed platform,
and a SDK library (named <code>netmito</code>) that you can use to create your own client.
We currently only support Rust for the SDK library. Python SDK is coming soon.</p>
<p>There are multiple ways to install the Mitosis CLI tool.
Choose any one of the methods below that best suit your needs.</p>
<h2 id="pre-compiled-binaries"><a class="header" href="#pre-compiled-binaries">Pre-compiled binaries</a></h2>
<p>Executable binaries are available for download on the <a href="https://github.com/stack-rs/mitosis/releases">GitHub Releases page</a>.
Download the binary and extract the archive.
The archive contains an <code>mito</code> executable which you can run to start your distributed platform.</p>
<h3 id="automated-installation-script"><a class="header" href="#automated-installation-script">Automated Installation Script</a></h3>
<p>We provide an installer script that automatically downloads and installs the latest version:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -LsSf https://github.com/stack-rs/mitosis/releases/latest/download/mito-installer.sh | sh
</code></pre>
<p><strong>For a specific version</strong> (adjust version number as needed, found at <a href="https://github.com/stack-rs/mitosis/releases">releases</a> page):</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -LsSf https://github.com/stack-rs/mitosis/releases/download/mito-v0.6.5/mito-installer.sh | sh
</code></pre>
<p>The installer script will:</p>
<ul>
<li>Detect your platform automatically</li>
<li>Download the appropriate binary</li>
<li>Install it to <code>$HOME/.cargo/bin</code></li>
<li>Add the directory to your PATH if needed</li>
</ul>
<h3 id="manual-installation"><a class="header" href="#manual-installation">Manual Installation</a></h3>
<p>You can also download the binary directly from the <a href="https://github.com/stack-rs/mitosis/releases">releases</a> page and install it manually.
To make it easier to run, put the path to the binary into your <code>PATH</code> or install it in a directory that is already in your <code>PATH</code>.
For example, do the following on Linux (glibc-based distributions):</p>
<pre><code class="language-bash">wget https://github.com/stack-rs/mitosis/releases/latest/download/mito-x86_64-unknown-linux-gnu.tar.xz
tar xf mito-x86_64-unknown-linux-gnu.tar.xz
cd mito-x86_64-unknown-linux-gnu
sudo install -m 755 mito /usr/local/bin/mito
</code></pre>
<p>If you are using older Linux distributions (with older glibc), you may need to install the musl-compiled releases:</p>
<pre><code class="language-bash">wget https://github.com/stack-rs/mitosis/releases/latest/download/mito-x86_64-unknown-linux-musl.tar.xz
tar xf mito-x86_64-unknown-linux-musl.tar.xz
cd mito-x86_64-unknown-linux-musl
sudo install -m 755 mito /usr/local/bin/mito
</code></pre>
<h3 id="verification"><a class="header" href="#verification">Verification</a></h3>
<p>After installation, verify that Mitosis is working correctly:</p>
<pre><code class="language-bash">mito --version
mito --help
</code></pre>
<h2 id="build-from-source-using-rust"><a class="header" href="#build-from-source-using-rust">Build from source using Rust</a></h2>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>You have to install pkg-config, libssl-dev if you want to build the binary from source.</p>
<h3 id="installing-with-cargo"><a class="header" href="#installing-with-cargo">Installing with Cargo</a></h3>
<p>To build the <code>mito</code> executable from source, you will first need to install Rust and Cargo.
Follow the instructions on the <a href="https://www.rust-lang.org/tools/install">Rust installation page</a>.</p>
<p>Once you have installed Rust, the following command can be used to build and install mito:</p>
<pre><code class="language-bash">cargo install mito
</code></pre>
<p>This will automatically download mito from <a href="https://crates.io/">crates.io</a>, build it, and install it in Cargo's global binary directory (<code>~/.cargo/bin/</code> by default).</p>
<p>You can run <code>cargo install mito</code> again whenever you want to update to a new version.
That command will check if there is a newer version, and re-install mito if a newer version is found.</p>
<p>To uninstall, run the command <code>cargo uninstall mito</code>.</p>
<h3 id="installing-the-latest-git-version-with-cargo"><a class="header" href="#installing-the-latest-git-version-with-cargo">Installing the latest git version with Cargo</a></h3>
<p>The version published to crates.io will ever so slightly be behind the version hosted on GitHub.
If you need the latest version you can build the git version of mito yourself.
Cargo makes this <strong><em>super easy</em></strong>!</p>
<pre><code class="language-bash">cargo install --git https://github.com/stack-rs/mitosis.git mito
</code></pre>
<p>Again, make sure to add the Cargo bin directory to your <code>PATH</code>.</p>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building from source</a></h3>
<p>If you want to build the binary from source, you can clone the repository and build it using Cargo.</p>
<pre><code class="language-bash">git clone https://github.com/stack-rs/mitosis.git
cd mitosis
cargo build --release
</code></pre>
<p>Then you can find the binary in <code>target/release/mito</code> and install or run it as you like.</p>
<h3 id="common-building-errors"><a class="header" href="#common-building-errors">Common building errors</a></h3>
<p>If you encounter compilation errors on rustls or aws-lc-sys in older Linux distributions, check gcc version and consider updating it.
For example on Ubuntu/Debian:</p>
<pre><code class="language-bash">sudo apt update -y
sudo apt upgrade -y
sudo apt install -y build-essential
sudo apt install -y gcc-10 g++-10 cpp-10
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 100 --slave /usr/bin/g++ g++ /usr/bin/g++-10 --slave /usr/bin/gcov gcov /usr/bin/gcov-10
</code></pre>
<p><strong>CentOS/RHEL/Fedora:</strong></p>
<pre><code class="language-bash">sudo dnf install -y gcc gcc-c++ openssl-devel pkgconfig
# OR for older versions:
sudo yum install -y gcc gcc-c++ openssl-devel pkgconfig
</code></pre>
<p><strong>Alpine Linux:</strong></p>
<pre><code class="language-bash">apk add --no-cache gcc musl-dev openssl-dev pkgconfig
</code></pre>
<h2 id="modifying-and-contributing"><a class="header" href="#modifying-and-contributing">Modifying and contributing</a></h2>
<p>If you are interested in making modifications to Mitosis itself, check out the <a href="https://github.com/stack-rs/mitosis/blob/master/CONTRIBUTING.md">Contributing Guide</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-a-coordinator"><a class="header" href="#running-a-coordinator">Running a Coordinator</a></h1>
<p>A Coordinator is a process that manages the execution of a workflow.
It is responsible for scheduling tasks, tracking their progress, and handling failures.
The Coordinator is a long-running process that is typically deployed as a service.</p>
<h2 id="external-requirements"><a class="header" href="#external-requirements">External Requirements</a></h2>
<p>The Coordinator requires access to several external services.
It needs a PostgreSQL database to store data, an S3-compatible storage service to store task artifacts or group attachments.
The Redis server is an optional service that acts as a pub/sub provider,
enabling clients to subscribe to and query more comprehensive details regarding the execution status of tasks.</p>
<p>For those services, you can use the docker-compose file provided in the repository.
First, Copy <code>.env.example</code> to <code>.env</code> and set the variables in it.
You have file variables to configure:</p>
<pre><code class="language-txt">DB_USERNAME=
DB_PASSWORD=
S3_USERNAME=
S3_PASSWORD=
KV_PASSWORD=
</code></pre>
<p>And then, run the following command to start the services:</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
<p>The Coordinator also requires a private and public key pair to sign and verify access tokens.
For the private and public keys, you can generate them using the following commands:</p>
<pre><code class="language-bash">openssl genpkey -algorithm ed25519 -out private.pem
openssl pkey -in private.pem -pubout -out public.pem
</code></pre>
<h2 id="starting-a-coordinator"><a class="header" href="#starting-a-coordinator">Starting a Coordinator</a></h2>
<p>To start a Coordinator, you need to provide a TOML file that configures the Coordinator.
The TOML file specifies the Coordinator's configuration, such as the address it binds to, the URL of the postgres database, and token expiry settings.
All configuration options are optional and have default values.</p>
<p>The Coordinator will merge the configuration from the file and the command-line arguments according to the following order (the latter overrides the former):</p>
<pre><code class="language-md">DEFAULT &lt;- `$CONFIG_DIR`/mitosis/config.toml &lt;- config file specified by `cli.config` or loal `config.toml` &lt;- env prefixed by `MITO_` &lt;- cli arguments

`$CONFIG_DIR` will be different on different platforms:

- Linux: `$XDG_CONFIG_HOME` or `$HOME`/.config
- macOS: `$HOME`/Library/Application Support
- Windows: {FOLDERID_RoamingAppData}
</code></pre>
<p>Here is an example of a Coordinator configuration file (you can also refer to <code>config.example.toml</code> in the repository):</p>
<pre><code class="language-toml">[coordinator]
bind = "127.0.0.1:5000"
db_url = "postgres://mitosis:mitosis@localhost/mitosis"
s3_url = "http://127.0.0.1:9000"
s3_access_key = "mitosis_access"
s3_secret_key = "mitosis_secret"
# redis_url is not set. It should be in format like "redis://:mitosis@localhost"
# redis_worker_password is not set by default and will be generated randomly
# redis_client_password is not set by default and will be generated randomly
# admin_user specifies the username of the admin user created on startup
admin_user = "mitosis_admin"
# admin_password specifies the password of the admin user created on startup
admin_password = "mitosis_admin"
access_token_private_path = "private.pem"
access_token_public_path = "public.pem"
access_token_expires_in = "7d"
heartbeat_timeout = "600s"
file_log = false
# log_path is not set. It will use the default rolling log file path if file_log is set to true
</code></pre>
<p>To start a Coordinator, run the following command:</p>
<pre><code class="language-bash">mito coordinator --config /path/to/coordinator.toml
</code></pre>
<p>The Coordinator will start and listen for incoming requests on the specified address.</p>
<p>We can also override the configuration settings using command-line arguments.
Note that the names of command-line arguments may not be the same as those in the configuration file.
For example, to change the address the Coordinator binds to, you can run:</p>
<pre><code class="language-bash">mito coordinator --config /path/to/coordinator.toml --bind 0.0.0.0:8000
</code></pre>
<p>The full list of command-line arguments can be found by running <code>mito coordinator --help</code>:</p>
<pre><code class="language-txt">Run the mitosis coordinator

Usage: mito coordinator [OPTIONS]

Options:
  -b, --bind &lt;BIND&gt;
          The address to bind to
      --config &lt;CONFIG&gt;
          The path of the config file
      --db &lt;DB_URL&gt;
          The database URL
      --s3 &lt;S3_URL&gt;
          The S3 URL
      --s3-access-key &lt;S3_ACCESS_KEY&gt;
          The S3 access key
      --s3-secret-key &lt;S3_SECRET_KEY&gt;
          The S3 secret key
      --redis &lt;REDIS_URL&gt;
          The Redis URL
      --redis-worker-password &lt;REDIS_WORKER_PASSWORD&gt;
          The Redis worker password
      --redis-client-password &lt;REDIS_CLIENT_PASSWORD&gt;
          The Redis client password
      --admin-user &lt;ADMIN_USER&gt;
          The admin username
      --admin-password &lt;ADMIN_PASSWORD&gt;
          The admin password
      --access-token-private-path &lt;ACCESS_TOKEN_PRIVATE_PATH&gt;
          The path to the private key, default to `private.pem`
      --access-token-public-path &lt;ACCESS_TOKEN_PUBLIC_PATH&gt;
          The path to the public key, default to `public.pem`
      --access-token-expires-in &lt;ACCESS_TOKEN_EXPIRES_IN&gt;
          The access token expiration time, default to 7 days
      --heartbeat-timeout &lt;HEARTBEAT_TIMEOUT&gt;
          The heartbeat timeout, default to 600 seconds
      --log-path &lt;LOG_PATH&gt;
          The log file path. If not specified, then the default rolling log file path would be used. If specified, then the log file would be exactly at the path specified
      --file-log
          Enable logging to file
  -h, --help
          Print help
  -V, --version
          Print version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-a-worker"><a class="header" href="#running-a-worker">Running a Worker</a></h1>
<p>A Worker is a process that executes tasks.
It is responsible for fetching tasks from the Coordinator, executing them, and reporting the results back to the Coordinator.
The Worker is a long-running process that is typically deployed as a service.</p>
<h2 id="environment-inside-a-worker"><a class="header" href="#environment-inside-a-worker">Environment inside a Worker</a></h2>
<p>Before starting a Worker, we need to understand the environment inside a Worker.</p>
<p>The Worker will spawn a new process for each task it runs and set up the following environment variables:</p>
<ul>
<li><code>MITO_TASK_UUID</code>: This will be set to the UUID of the task being executed.</li>
<li><code>MITO_NEW_TASK</code>: This will be set to the path a file where you can write a new task specification (i.e., SubmitTaskReq) in json format for the Worker to submit it on behalf of you, as a downstream task of the current task.</li>
<li><code>MITO_UPSTREAM_TASK_UUID</code>: This will be set to the UUID of the upstream task if the current task is submitted by another task while running.</li>
<li><code>MITO_RESOURCE_DIR</code>: This will be set to the path of a directory where you can find the resources (i.e., attachments) of the task.</li>
<li><code>MITO_RESULT_DIR</code>: This will be set to the path of a directory where you can store the results of the task. The Worker will pack the directory and upload it as the artifacts of the task if it is not empty.</li>
<li><code>MITO_EXEC_DIR</code>: This will be set to the path of a directory where you can store execution logs. The Worker will pack the directory and upload it as the artifacts of the task if it is not empty.</li>
</ul>
<h2 id="starting-a-worker"><a class="header" href="#starting-a-worker">Starting a Worker</a></h2>
<p>To start a Worker, you need to provide a TOML file that configures the Worker.
The TOML file specifies the Worker's configuration, such as the polling (fetching) interval, the URL of the Coordinator, and the the groups allowed to submit tasks to it.
All configuration options are optional and have default values.</p>
<p>The Worker will merge the configuration from the file and the command-line arguments according to the following order (the latter overrides the former):</p>
<pre><code class="language-md">DEFAULT &lt;- `$CONFIG_DIR`/mitosis/config.toml &lt;- config file specified by `cli.config` or loal `config.toml` &lt;- env prefixed by `MITO_` &lt;- cli arguments

`$CONFIG_DIR` will be different on different platforms:

- Linux: `$XDG_CONFIG_HOME` or `$HOME`/.config
- macOS: `$HOME`/Library/Application Support
- Windows: {FOLDERID_RoamingAppData}
</code></pre>
<p>Here is an example of a Worker configuration file (you can also refer to <code>config.example.toml</code> in the repository):</p>
<pre><code class="language-toml">[worker]
coordinator_addr = "http://127.0.0.1:5000"
polling_interval = "3m"
heartbeat_interval = "5m"
lifetime = "7d"
# credential_path is not set
# user is not set
# password is not set
# groups are not set, default to the user's group
# tags are not set
file_log = false
# shared_log is not set, default to false. When enabled, all workers share a centralized log file with daily rotation (max 3 files)
# log_path is not set. It will use the default rolling log file path if file_log is set to true
#   - If shared_log is enabled and log_path is not set, it will use workers.log in cache directory
#   - If shared_log is disabled and log_path is not set, it will use {worker_uuid}.log in cache directory
# lifetime is not set, default to the coordinator's setting
</code></pre>
<p>To start a Worker, run the following command:</p>
<pre><code class="language-bash">mito worker --config /path/to/worker.toml
</code></pre>
<p>The Worker will start and fetch tasks from the Coordinator at the specified interval.</p>
<p>We can also override the configuration settings using command-line arguments.
Note that the names of command-line arguments may not be the same as those in the configuration file.
For example, to change the polling interval, you can run:</p>
<pre><code class="language-bash">mito worker --config /path/to/worker.toml --polling-interval 5m
</code></pre>
<p>You can also specify the groups and their roles to this Worker using the <code>--groups</code> argument.
The default roles for the groups are <code>Write</code>, meaning that the groups can submit tasks to this Worker.
Groups have <code>Read</code> roles can query the Worker for its status and tasks.
Groups have <code>Admin</code> roles can manage the Worker, such as stopping it or changing its configuration.</p>
<pre><code class="language-bash">mito worker --config /path/to/worker.toml --groups group1,group2:write,group3:read,group4:admin
</code></pre>
<p>This will grant group1 and group2 <code>Write</code> roles, group3 <code>Read</code> role, and group4 <code>Admin</code> role to the Worker.
The user who creates the Worker will be automatically granted the <code>Admin</code> role of the Worker.</p>
<p>Another important argument is <code>--tags</code>, the tags of the Worker.
It defines the characteristics of the Worker, such as its capabilities or the type of tasks it can handle.
It is designed for some specific tasks who has special requirements on Workers.
Only when a Worker's tags are empty or are the subset of the task's tags, the Worker can fetch the task.</p>
<p>The full list of command-line arguments can be found by running <code>mito worker --help</code>:</p>
<pre><code class="language-txt">Run a mitosis worker

Usage: mito worker [OPTIONS]

Options:
      --config &lt;CONFIG&gt;
          The path of the config file
  -c, --coordinator &lt;COORDINATOR_ADDR&gt;
          The address of the coordinator
      --polling-interval &lt;POLLING_INTERVAL&gt;
          The interval to poll tasks or resources
      --heartbeat-interval &lt;HEARTBEAT_INTERVAL&gt;
          The interval to send heartbeat
      --credential-path &lt;CREDENTIAL_PATH&gt;
          The path of the user credential file
  -u, --user &lt;USER&gt;
          The username of the user
  -p, --password &lt;PASSWORD&gt;
          The password of the user
  -g, --groups [&lt;GROUPS&gt;...]
          The groups allowed to submit tasks to this worker
  -t, --tags [&lt;TAGS&gt;...]
          The tags of this worker
      --log-path &lt;LOG_PATH&gt;
          The log file path. If not specified, then the default rolling log file path would be used. If specified, then the log file would be exactly at the path specified
      --file-log
          Enable logging to file
      --lifetime &lt;LIFETIME&gt;
          The lifetime of the worker to alive (e.g., 7d, 1year)
  -h, --help
          Print help
  -V, --version
          Print version
</code></pre>
<h2 id="logging-configuration"><a class="header" href="#logging-configuration">Logging Configuration</a></h2>
<p>Workers support flexible logging configurations to help you track and debug task execution:</p>
<h3 id="file-logging"><a class="header" href="#file-logging">File Logging</a></h3>
<p>Enable file logging with the <code>--file-log</code> flag or by setting <code>file_log = true</code> in the configuration file. This will write worker logs to disk for persistent storage.</p>
<h3 id="shared-rolling-logs-v065"><a class="header" href="#shared-rolling-logs-v065">Shared Rolling Logs (v0.6.5+)</a></h3>
<p>Starting from version 0.6.5, workers support shared rolling logs - a centralized logging mechanism that allows multiple workers to write to the same log file with automatic daily rotation:</p>
<ul>
<li><strong>Shared Mode</strong>: When <code>shared_log = true</code>, all workers write to a single <code>workers.log</code> file in the cache directory</li>
<li><strong>Individual Mode</strong>: When <code>shared_log = false</code> (default), each worker writes to its own <code>{worker_uuid}.log</code> file</li>
<li><strong>Rotation</strong>: Shared logs rotate daily with a maximum of 3 log files retained</li>
</ul>
<p>This feature is particularly useful when managing multiple workers on the same machine, as it simplifies log management and aggregation.</p>
<p><strong>Example configuration:</strong></p>
<pre><code class="language-toml">[worker]
file_log = true
shared_log = true  # Enable shared rolling logs
# log_path is optional - if not specified, uses default cache directory
</code></pre>
<p><strong>Note:</strong> The cache directory location varies by platform:</p>
<ul>
<li>Linux: <code>$XDG_CACHE_HOME</code> or <code>$HOME/.cache/mitosis</code></li>
<li>macOS: <code>$HOME/Library/Caches/mitosis</code></li>
<li>Windows: <code>{FOLDERID_LocalAppData}\mitosis</code></li>
</ul>
<pre><code>
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-a-client"><a class="header" href="#running-a-client">Running a Client</a></h1>
<p>A Client is a process that interact with the Coordinator.
It is responsible for creating tasks, querying their results, and managing workers or groups.
The Client is a short-lived process that is typically run on-demand.</p>
<h2 id="starting-a-client"><a class="header" href="#starting-a-client">Starting a Client</a></h2>
<p>While it's possible to provide a TOML configuration file to the client,
it's often unnecessary given the limited number of configuration items, all of which pertain to login procedures.
But it can be useful if you want to set some default values for the client.</p>
<p>The Client will merge the configuration from the file and the command-line arguments according to the following order (the latter overrides the former):</p>
<pre><code class="language-md">DEFAULT &lt;- `$CONFIG_DIR`/mitosis/config.toml &lt;- config file specified by `cli.config` or loal `config.toml` &lt;- env prefixed by `MITO_` &lt;- cli arguments

`$CONFIG_DIR` will be different on different platforms:

- Linux: `$XDG_CONFIG_HOME` or `$HOME`/.config
- macOS: `$HOME`/Library/Application Support
- Windows: {FOLDERID_RoamingAppData}
</code></pre>
<p>Typically, to start a Client, we can simply run the following command to enter interactive mode:</p>
<pre><code class="language-bash">mito client -i
</code></pre>
<p>If a user has never logged in or if his/her session has expired, the Client will prompt them to re-input their username and password for authentication.
Alternatively, they can directly specify their username (<code>-u</code>) or password (<code>-p</code>) during execution.
Once authenticated, the Client will retain their credentials in a file for future use.</p>
<p>We recommend using the interactive mode for most operations, as it provides a more user-friendly experience. It will prompt you something like this:</p>
<pre><code class="language-txt">[mito::client]&gt;
</code></pre>
<p>You can press <code>CTRL-D</code> or type in <code>exit</code> or <code>quit</code> to leave the interactive mode. <code>CTRL-C</code> will just clear the current line and prompt you again.</p>
<p>We can also directly run a command without entering interactive mode by specifying the command as an argument.
For example, to create a new user, we can run:</p>
<pre><code class="language-bash">mito client admin users create new_user_name new_password
</code></pre>
<p>The full list of command-line arguments can be found by running <code>mito client --help</code>:</p>
<pre><code class="language-txt">Run a mitosis client

Usage: mito client [OPTIONS] [COMMAND]

Commands:
  admin    Admin operations, including shutdown the coordinator, chaning user password, etc
  auth     Authenticate current user
  login    Login with username and password
  users    Manage users, including changing password, querying the accessible groups etc
  groups   Manage groups, including creating a group, querying groups, etc
  tasks    Manage tasks, including submitting a task, querying tasks, etc
  workers  Manage workers, including querying workers, cancel workers, etc
  cmd      Run an external command
  quit     Quit the client's interactive mode [aliases: exit]
  help     Print this message or the help of the given subcommand(s)

Options:
      --config &lt;CONFIG&gt;
          The path of the config file
  -c, --coordinator &lt;COORDINATOR_ADDR&gt;
          The address of the coordinator
      --credential-path &lt;CREDENTIAL_PATH&gt;
          The path of the user credential file
  -u, --user &lt;USER&gt;
          The username of the user
  -p, --password &lt;PASSWORD&gt;
          The password of the user
  -i, --interactive
          Enable interactive mode
      --retain
          Whether to retain the previous login state without refetching the credential
  -h, --help
          Print help
  -V, --version
          Print version
</code></pre>
<p>To know how each subcommand works, you can run <code>mito client &lt;subcommand&gt; --help</code>.
For example, to know how to create a new user, you can run <code>mito client admin users create --help</code>:</p>
<pre><code class="language-txt">Create a new user

Usage: mito client admin users create [OPTIONS] [USERNAME] [PASSWORD]

Arguments:
  [USERNAME]  The username of the user
  [PASSWORD]  The password of the user

Options:
      --admin    Whether to grant the new user as an admin user
  -h, --help     Print help
  -V, --version  Print version
</code></pre>
<p>For the rest of this section, we will explain the common use cases of the Client on different scenarios.
For the sake of convenience, we will assume that the user is already in interactive mode.
And for the direct executing mode, it only requires adding "mito client" at the front.</p>
<h2 id="admin-sub-commands"><a class="header" href="#admin-sub-commands"><code>admin</code> sub-commands</a></h2>
<p>Input <code>help admin</code> to show the help message of the <code>admin</code> sub-commands:</p>
<pre><code class="language-txt">Admin operations, including shutdown the coordinator, chaning user password, etc

Usage: admin &lt;COMMAND&gt;

Commands:
  users     Manage users
  shutdown  Shutdown the coordinator
  groups    Manage groups
  tasks     Manage a task
  workers   Manage a worker
  help      Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help
</code></pre>
<p>The admin operations are only available to admin users.</p>
<p>For example, we can create a new user by running the following command:</p>
<pre><code class="language-txt">admin users create test_user_name test_user_password
</code></pre>
<p>We can change password of a user by running:</p>
<pre><code class="language-txt">admin users change-password test_user_name new_test_user_password
</code></pre>
<h2 id="groups-sub-commands"><a class="header" href="#groups-sub-commands"><code>groups</code> sub-commands</a></h2>
<p>Input <code>help groups</code> to show the help message of the <code>groups</code> sub-commands:</p>
<pre><code class="language-txt">Manage groups, including creating a group, querying groups, etc

Usage: groups &lt;COMMAND&gt;

Commands:
  create       Create a new group
  get          Get the information of a group
  update-user  Update the roles of users to a group
  remove-user  Remove the accessibility of users from a group
  attachments  Query, upload, download or delete an attachment
  help         Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help
</code></pre>
<p>We can manage group related operations with the <code>groups</code> sub-commands, such as creating a new group, querying a group, managing users' access to a group, and managing attachments of a group.</p>
<p>We can create a new group by running the following command:</p>
<pre><code class="language-txt">groups create test_group
</code></pre>
<p>This will create a group called <code>test_group</code> containing the current logged in user.
This user will be granted the <code>Admin</code> role to this group to manage it.</p>
<p>We can get the information of a group by running:</p>
<pre><code class="language-txt">groups get test_group
</code></pre>
<h3 id="attachments-sub-commands"><a class="header" href="#attachments-sub-commands"><code>attachments</code> sub-commands</a></h3>
<p>Input <code>help groups attachments</code> or <code>groups attachments -h</code> to show the help message of the <code>attachments</code> sub-commands:</p>
<pre><code class="language-txt">Query, upload, download or delete an attachment

Usage: groups attachments &lt;COMMAND&gt;

Commands:
  delete    Delete an attachment from a group
  upload    Upload an attachment to a group
  get       Get the metadata of an attachment
  download  Download an attachment of a group
  query     Query attachments subject to the filter
  help      Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help
</code></pre>
<p>This is used to upload, download, delete or query attachments of a group.</p>
<p>For example, to upload an attachment to a group, we can run:</p>
<pre><code class="language-txt">groups attachments upload -g test_group local.tar.gz attachment_key
</code></pre>
<p>You can also just run <code>groups attachments upload local.tar.gz</code>.
This will directly upload the file to the current group you are in and use the file name as the attachment key.</p>
<p>Also, you can specify the attachment key to be a directory-like string, ending with a <code>/</code>. This will smartly upload local file to <code>attachment_key/local_file_name</code>.</p>
<p>For example, to upload a file <code>local.tar.gz</code> to a directory <code>dir/</code> in the group, you can run:</p>
<pre><code class="language-txt">groups attachments upload -g test_group local.tar.gz dir/
</code></pre>
<p>This will save the attachment with key <code>dir/local.tar.gz</code>.</p>
<p>To download an attachment of a group, you can just:</p>
<pre><code class="language-txt">groups attachments download -g test_group dir/local.tar.gz
</code></pre>
<p>We also offer a smart mode to make downloading easier.</p>
<p>You can specify the group_name in the first segment of the attachment key, separated by a <code>/</code>, if no group_name specified by <code>-g</code>, and we will use the last segment of the attachment key as the local file name if no output path specified by <code>-o</code>. For example:</p>
<pre><code class="language-txt">groups attachments download test_group/dir/local.tar.gz
</code></pre>
<p>This will download the attachment <code>dir/local.tar.gz</code> from group <code>test_group</code> and save it as <code>local.tar.gz</code> in the current directory.</p>
<h2 id="tasks-sub-commands"><a class="header" href="#tasks-sub-commands"><code>tasks</code> sub-commands</a></h2>
<p>Input <code>help tasks</code> to show the help message of the <code>tasks</code> sub-commands:</p>
<pre><code class="language-txt">Manage tasks, including submitting a task, querying tasks, etc

Usage: tasks &lt;COMMAND&gt;

Commands:
  submit         Submit a task
  get            Get the info of a task
  query          Query tasks subject to the filter
  cancel         Cancel a task
  update-labels  Replace labels of a task
  change         Update the spec of a task
  artifacts      Query, upload, download or delete an artifact
  help           Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help
</code></pre>
<p>Submit a task to the Coordinator can be as simple as running the following command:</p>
<pre><code class="language-txt">tasks submit -- echo hello
</code></pre>
<p>The content after <code>--</code> is the command to run on the worker. It will return a UUID to identify the task.</p>
<p>You can also specify the group to submit the task to by using the <code>-g</code> option.</p>
<p>The <code>--labels</code> are used to mark the task for querying later, it won't affect how the task is fetched ans executed.</p>
<p>The <code>--tags</code> are used to define the characteristics of the task, such as its requirements on the Worker.
Only when a Worker's tags are empty or are the subset of the task's tags, the Worker can fetch the task.</p>
<p>You can also set some environment variables for the task by using the <code>-e</code> option.</p>
<pre><code class="language-txt">tasks submit -g test_group -t wireless,4g -l mobile,video -e TEST_KEY=1,TEST_VAL=2 -- echo hello
</code></pre>
<p>For the output of the task, we allow 3 types of output to be collected:</p>
<ol>
<li><strong>Result</strong>: Files put under the directory specified by the environment variable <code>MITO_RESULT_DIR</code> will be packed into an artifact and uploaded to the Coordinator.
If the directory is empty, no artifact will be created.</li>
<li><strong>Exec</strong>: Files put under the directory specified by the environment variable <code>MITO_EXEC_DIR</code> will be packed into an artifact and uploaded to the Coordinator.
If the directory is empty, no artifact will be created.</li>
<li><strong>Terminal</strong>: If the <code>--terminal</code> option is specified, the standard output and error of the executed task will be collected and uploaded to the Coordinator.
The terminal output will be stored in a file named <code>stdout.log</code> and <code>stderr.log</code> respectively in an artifact.</li>
</ol>
<p>Now, we get a submitted task's information by providing its UUID:</p>
<pre><code class="language-txt">tasks get e07a2bf2-166d-40b5-8bb6-a78104c072f9
</code></pre>
<p>Or we can just query a list of tasks with label <code>mobile</code>:</p>
<pre><code class="language-txt">tasks query -l mobile
</code></pre>
<p>More filter options can be found in the help message by executing <code>tasks query -h</code></p>
<p>For a task, we can also cancel it, update its labels or change its specification to run with its UUID provides. For example:</p>
<pre><code class="language-txt">tasks cancel e07a2bf2-166d-40b5-8bb6-a78104c072f9
</code></pre>
<p>This will cancel the task if it is not started yet. It is not allowed to cancel a running or finished task.</p>
<p>To change how the task is executed (i.e., the spec of this task), we can run:</p>
<pre><code class="language-txt">tasks change e07a2bf2-166d-40b5-8bb6-a78104c072f9 --terminal -- echo world
</code></pre>
<p>This will alter the task to collect standard output and error when finishes, and execute <code>echo world</code> instead of <code>echo hello</code>.</p>
<p>We can download the results (a collection of files generated by a task as output) collected by the task as an artifact.</p>
<p>It is easy to download an artifact of a task by providing its UUID. But you also have to specify the output type you want.
There are three types of output: <code>result</code>, <code>exec-log</code>, and <code>std-log</code>. You can also specify the output path to download the artifact to with <code>-o</code> argument.</p>
<pre><code class="language-txt">tasks artifacts download e07a2bf2-166d-40b5-8bb6-a78104c072f9 result
</code></pre>
<h2 id="workers-sub-commands"><a class="header" href="#workers-sub-commands"><code>workers</code> sub-commands</a></h2>
<p>Input <code>help workers</code> to show the help message of the <code>workers</code> sub-commands:</p>
<pre><code class="language-txt">Manage workers, including querying workers, cancel workers, etc

Usage: workers &lt;COMMAND&gt;

Commands:
  cancel        Cancel a worker
  update-tags   Replace tags of a worker
  update-roles  Update the roles of groups to a worker
  remove-roles  Remove the accessibility of groups from a worker
  get           Get information about a worker
  query         Query workers subject to the filter
  help          Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help
</code></pre>
<p>We can manage a worker, and get relevant information about it with the <code>workers</code> sub-commands.</p>
<p>For example, we can stop a worker by running:</p>
<pre><code class="language-txt">workers cancel b168dbe6-5c44-4529-a3b4-51940d6bb3c5
</code></pre>
<p>Or we can update the tags of a worker by running:</p>
<pre><code class="language-txt">workers update-tags b168dbe6-5c44-4529-a3b4-51940d6bb3c5 wired file
</code></pre>
<p>And we can grant another group <code>Write</code> access to this worker (it means the group can submit tasks to this worker) by running:</p>
<pre><code class="language-txt">workers update-roles b168dbe6-5c44-4529-a3b4-51940d6bb3c5 test_group:admin another_group:write
</code></pre>
<p>You can perform the opposite action to remove certain groups' access permissions to the Worker using the <code>remove-roles</code> subcommand.</p>
<h2 id="cmd-sub-commands"><a class="header" href="#cmd-sub-commands"><code>cmd</code> sub-commands</a></h2>
<p>Input <code>help cmd</code> to show the help message of the <code>cmd</code> sub-commands:</p>
<pre><code class="language-txt">Run an external command

Usage: cmd [OPTIONS] [-- &lt;COMMAND&gt;...]

Arguments:
  [COMMAND]...  The command to run

Options:
  -s, --split  Do not merge the command into one string
  -h, --help   Print help
</code></pre>
<p>We can use this sub-command to run an external command. For example, to list files in the current directory, we can run:</p>
<pre><code>cmd -- ls -hal
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-manager-to-manage-multiple-workers"><a class="header" href="#use-manager-to-manage-multiple-workers">Use Manager to manage multiple workers</a></h1>
<p>The Manager provides a convenient way to manage multiple Workers from a single command interface. It allows you to spawn, monitor, and terminate Workers efficiently.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The manager component is designed to handle worker lifecycle management, including:</p>
<ul>
<li><strong>Status monitoring</strong>: Check the status of all running workers</li>
<li><strong>Worker spawning</strong>: Launch multiple workers with configurable parameters</li>
<li><strong>Worker termination</strong>: Kill all running workers at once</li>
</ul>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<h3 id="status"><a class="header" href="#status">Status</a></h3>
<p>Check the status of all running workers:</p>
<pre><code class="language-bash">mito manager status
</code></pre>
<p>This command:</p>
<ul>
<li>Lists all currently running <code>mito worker</code> processes</li>
<li>Shows detailed process information (PID, CPU usage, memory, etc.)</li>
<li>Displays the total count of active workers</li>
</ul>
<h3 id="spawn-workers"><a class="header" href="#spawn-workers">Spawn Workers</a></h3>
<p>Launch multiple worker processes:</p>
<pre><code class="language-bash">mito manager spawn &lt;count&gt; [worker-options]
</code></pre>
<ul>
<li><code>count</code>: Number of workers to spawn (must be greater than 0)</li>
<li><code>worker-options</code> All available worker options can be passed to the spawn command.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash"># Spawn 5 workers with default configuration
mito manager spawn 5

# Spawn 3 workers with custom coordinator and tags
mito manager spawn 3 --coordinator "127.0.0.1:5000" --tags "gpu,cuda"

# Spawn workers with specific groups and file logging
mito manager spawn 2 --groups "batch-processing" --file-log --log-path "/var/log/mito"
</code></pre>
<p><strong>Spawning Process:</strong></p>
<ul>
<li>Shows a progress bar during worker creation</li>
<li>Workers are spawned as detached processes (background execution)</li>
<li>Each worker runs independently with its own process ID</li>
<li>After spawning, displays the current total count of running workers</li>
</ul>
<h3 id="kill-workers"><a class="header" href="#kill-workers">Kill Workers</a></h3>
<p>Terminate all running worker processes:</p>
<pre><code class="language-bash">mito manager kill
</code></pre>
<p>This command:</p>
<ul>
<li>Finds all processes matching <code>mito worker</code></li>
<li>Terminates them using <code>pkill</code></li>
<li>Confirms successful termination or reports if no workers were found</li>
</ul>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>When spawning workers, the manager automatically sets:</p>
<ul>
<li><code>NO_COLOR=1</code>: Disables colored output for consistent logging</li>
<li><code>MITO_FILE_LOG_LEVEL</code>: Controls file logging level, if will inherit the current environment variable value and default to <code>info</code> if not set</li>
</ul>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Monitor before spawning</strong>: Always check current worker status before spawning new ones</li>
<li><strong>Resource awareness</strong>: Consider system resources when spawning multiple workers</li>
<li><strong>Configuration consistency</strong>: Use consistent worker configurations across spawned instances</li>
<li><strong>Logging strategy</strong>: Enable file logging for persistent worker logs</li>
</ol>
<h2 id="example-workflow"><a class="header" href="#example-workflow">Example Workflow</a></h2>
<pre><code class="language-bash"># Check current worker status
mito manager status

# Spawn 4 workers with GPU tags for ML workloads
mito manager spawn 4 --tags "gpu,ml" --groups "training" --file-log

# Monitor status after spawning
mito manager status

# When done, terminate all workers
mito manager kill
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p><strong>No workers showing in status:</strong></p>
<ul>
<li>Ensure workers are properly spawned</li>
<li>Check if coordinator is running and accessible</li>
<li>Verify worker configuration parameters</li>
</ul>
<p><strong>Failed to spawn workers:</strong></p>
<ul>
<li>Check system resources (memory, CPU)</li>
<li>Verify coordinator connectivity</li>
<li>Ensure proper permissions for process creation</li>
</ul>
<p><strong>Workers not terminating:</strong></p>
<ul>
<li>Check for zombie processes: <code>ps -aux | grep mito</code></li>
<li>Force kill if necessary: <code>sudo pkill -9 -f "mito worker"</code></li>
<li>Restart the manager if processes are stuck</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>This document provides a comprehensive overview of Mitosis's architecture, components, and data flow.</p>
<h2 id="system-components"><a class="header" href="#system-components">System Components</a></h2>
<h3 id="coordinator"><a class="header" href="#coordinator">Coordinator</a></h3>
<p>The Coordinator is the central management service that orchestrates the entire Mitosis system. It handles:</p>
<ul>
<li><strong>Task Management</strong>: Receives, validates, and stores task submissions</li>
<li><strong>User Authentication</strong>: Manages user sessions and permissions using JWT tokens</li>
<li><strong>Group Authorization</strong>: Enforces group-based access controls</li>
<li><strong>Worker Registration</strong>: Tracks available workers and their capabilities</li>
<li><strong>Scheduling</strong>: Matches tasks with appropriate workers based on groups and tags</li>
<li><strong>State Management</strong>: Maintains task execution states and progress tracking</li>
<li><strong>Artifact Storage</strong>: Coordinates with S3-compatible storage for task outputs</li>
</ul>
<p><strong>Key Dependencies:</strong></p>
<ul>
<li>PostgreSQL for persistent data storage</li>
<li>S3-compatible storage for artifact management</li>
<li>Redis (optional) for pub/sub notifications and caching</li>
<li>Ed25519 key pair for JWT token signing</li>
</ul>
<h3 id="worker"><a class="header" href="#worker">Worker</a></h3>
<p>Workers are the execution nodes that run tasks assigned by the Coordinator. Each worker:</p>
<ul>
<li><strong>Task Polling</strong>: Regularly checks for available tasks matching its configuration</li>
<li><strong>Environment Isolation</strong>: Provides clean execution environments for tasks</li>
<li><strong>Artifact Collection</strong>: Gathers task outputs from designated directories</li>
<li><strong>Heartbeat Reporting</strong>: Sends periodic status updates to maintain liveness</li>
<li><strong>Tag-based Matching</strong>: Only accepts tasks compatible with its configured tags</li>
<li><strong>Group Membership</strong>: Serves tasks from groups it has been granted access to</li>
</ul>
<p><strong>Execution Flow:</strong></p>
<ol>
<li>Poll Coordinator for available tasks</li>
<li>Validate task compatibility (groups, tags)</li>
<li>Create isolated execution environment</li>
<li>Execute task command with configured environment variables</li>
<li>Collect artifacts from <code>MITO_RESULT_DIR</code>, <code>MITO_EXEC_DIR</code></li>
<li>Upload results and update task status</li>
</ol>
<h3 id="client"><a class="header" href="#client">Client</a></h3>
<p>The Client provides both interactive and programmatic interfaces for users to interact with the system:</p>
<ul>
<li><strong>Interactive Mode</strong>: Shell-like interface for real-time system interaction</li>
<li><strong>Batch Mode</strong>: Direct command execution for scripting and automation</li>
<li><strong>Task Management</strong>: Submit, query, and manage task execution</li>
<li><strong>User Administration</strong>: Create and manage users (admin only)</li>
<li><strong>Group Management</strong>: Create groups and manage member permissions</li>
<li><strong>Worker Management</strong>: Monitor and control worker nodes</li>
<li><strong>Artifact Operations</strong>: Upload group attachments and download task results</li>
</ul>
<h2 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h2>
<h3 id="task-submission-flow"><a class="header" href="#task-submission-flow">Task Submission Flow</a></h3>
<pre><code>Client  Coordinator  Database
           
   Validates user credentials and permissions
   Stores task specification in database
   Returns task UUID to client
</code></pre>
<h3 id="task-execution-flow"><a class="header" href="#task-execution-flow">Task Execution Flow</a></h3>
<pre><code>Worker  Coordinator  Database  S3 Storage
                        
   Polls for tasks based on groups/tags
   Updates task status (pending  running  completed/failed)
   Uploads artifacts and execution logs
</code></pre>
<h3 id="monitoring-flow-with-redis"><a class="header" href="#monitoring-flow-with-redis">Monitoring Flow (with Redis)</a></h3>
<pre><code>Coordinator  Redis  Client
                     
      Publishes task status updates
      Client subscribes to real-time notifications
</code></pre>
<h2 id="access-control-model"><a class="header" href="#access-control-model">Access Control Model</a></h2>
<h3 id="users-and-groups"><a class="header" href="#users-and-groups">Users and Groups</a></h3>
<ul>
<li>Every user automatically gets a group with the same name</li>
<li>Users can create additional groups and manage membership</li>
<li>Group roles define access levels: <code>Read</code>, <code>Write</code>, <code>Admin</code></li>
</ul>
<h3 id="worker-permissions"><a class="header" href="#worker-permissions">Worker Permissions</a></h3>
<p>Workers are configured with group access levels:</p>
<ul>
<li><strong>Write</strong>: Group members can submit tasks to this worker</li>
<li><strong>Read</strong>: Group members can query worker status</li>
<li><strong>Admin</strong>: Group members can manage worker configuration</li>
</ul>
<h3 id="task-routing"><a class="header" href="#task-routing">Task Routing</a></h3>
<p>Tasks are routed to workers based on:</p>
<ol>
<li><strong>Group Membership</strong>: Worker must have access to the task's target group</li>
<li><strong>Tag Compatibility</strong>: Worker tags must be empty or contain all task tags</li>
<li><strong>Availability</strong>: Worker must be active and not at capacity</li>
</ol>
<h2 id="storage-architecture"><a class="header" href="#storage-architecture">Storage Architecture</a></h2>
<h3 id="database-schema-postgresql"><a class="header" href="#database-schema-postgresql">Database Schema (PostgreSQL)</a></h3>
<ul>
<li><strong>Users</strong>: Authentication and profile information</li>
<li><strong>Groups</strong>: Group definitions and membership</li>
<li><strong>Tasks</strong>: Task specifications, state, and metadata</li>
<li><strong>Workers</strong>: Worker registration and configuration</li>
<li><strong>Artifacts / Attachments</strong>: File metadata and S3 object references</li>
</ul>
<h3 id="object-storage-s3"><a class="header" href="#object-storage-s3">Object Storage (S3)</a></h3>
<ul>
<li><strong>Task Artifacts</strong>: Results, logs, and execution outputs</li>
<li><strong>Group Attachments</strong>: Shared files accessible to group members</li>
<li><strong>Bucket Structure</strong>: Organized by groups and artifact types</li>
</ul>
<h3 id="cache-layer-redis"><a class="header" href="#cache-layer-redis">Cache Layer (Redis)</a></h3>
<ul>
<li><strong>Session Management</strong>: JWT token validation and user sessions</li>
<li><strong>Pub/Sub</strong>: Real-time notifications for task status changes</li>
</ul>
<h2 id="security-model"><a class="header" href="#security-model">Security Model</a></h2>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<ul>
<li>JWT tokens signed with Ed25519 private key</li>
<li>Configurable token expiration (default: 7 days)</li>
<li>Credential caching for user convenience</li>
</ul>
<h3 id="authorization"><a class="header" href="#authorization">Authorization</a></h3>
<ul>
<li>Role-based access control at group level</li>
<li>API endpoint protection based on user permissions</li>
<li>Resource isolation between groups</li>
</ul>
<h2 id="scalability-considerations"><a class="header" href="#scalability-considerations">Scalability Considerations</a></h2>
<h3 id="horizontal-scaling"><a class="header" href="#horizontal-scaling">Horizontal Scaling</a></h3>
<ul>
<li><strong>Multiple Workers</strong>: Add workers to increase task execution capacity</li>
<li><strong>Load Balancing</strong>: Coordinator can handle multiple concurrent clients</li>
<li><strong>Database Partitioning</strong>: Tasks and artifacts can be partitioned by group</li>
</ul>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<ul>
<li><strong>Connection Pooling</strong>: Database connections are pooled and reused</li>
<li><strong>Batch Operations</strong>: Multiple tasks can be submitted in batches</li>
<li><strong>Async Processing</strong>: Non-blocking I/O throughout the system</li>
</ul>
<h3 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h3>
<ul>
<li><strong>Worker Tagging</strong>: Allows targeting tasks to specific hardware capabilities</li>
<li><strong>Heartbeat Monitoring</strong>: Automatic worker health checking and cleanup</li>
<li><strong>Configurable Timeouts</strong>: Prevents resource leaks from stalled tasks</li>
</ul>
<h2 id="deployment-patterns"><a class="header" href="#deployment-patterns">Deployment Patterns</a></h2>
<h3 id="single-node-development"><a class="header" href="#single-node-development">Single-Node Development</a></h3>
<ul>
<li>All components on one machine</li>
<li>Docker Compose for external dependencies</li>
<li>Suitable for testing and small workloads</li>
</ul>
<h3 id="multi-node-production"><a class="header" href="#multi-node-production">Multi-Node Production</a></h3>
<ul>
<li>Coordinator on dedicated server</li>
<li>Workers distributed across compute nodes</li>
<li>Shared database and storage infrastructure</li>
<li>Load balancer for coordinator high availability</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-guide"><a class="header" href="#troubleshooting-guide">Troubleshooting Guide</a></h1>
<p>This guide covers common issues you might encounter when setting up and running Mitosis, along with their solutions.</p>
<h2 id="installation-issues"><a class="header" href="#installation-issues">Installation Issues</a></h2>
<h3 id="binary-not-found-after-installation"><a class="header" href="#binary-not-found-after-installation">Binary Not Found After Installation</a></h3>
<p><strong>Problem</strong>: <code>mito: command not found</code> after installation.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>
<p>Verify the binary location:</p>
<pre><code class="language-bash">which mito
find / -name "mito" 2&gt;/dev/null
</code></pre>
</li>
<li>
<p>Add to PATH if needed:</p>
<pre><code class="language-bash">export PATH="$HOME/.cargo/bin:$PATH"
# Add to your shell profile (.bashrc, .zshrc, etc.)
echo 'export PATH="$HOME/.cargo/bin:$PATH"' &gt;&gt; ~/.bashrc
</code></pre>
</li>
</ol>
<h3 id="permission-denied"><a class="header" href="#permission-denied">Permission Denied</a></h3>
<p><strong>Problem</strong>: Permission errors when running the installer or binary.</p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-bash"># Make binary executable
chmod +x mito

# Fix installer permissions
chmod +x mito-installer.sh
</code></pre>
<h3 id="ssltls-certificate-issues"><a class="header" href="#ssltls-certificate-issues">SSL/TLS Certificate Issues</a></h3>
<p><strong>Problem</strong>: Certificate verification errors during download.</p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-bash"># Update certificates
sudo apt-get update &amp;&amp; sudo apt-get install ca-certificates

# Or bypass for known-safe sources (not recommended for production)
curl -k --proto '=https' --tlsv1.2 -LsSf [URL]
</code></pre>
<h2 id="build-issues"><a class="header" href="#build-issues">Build Issues</a></h2>
<h3 id="missing-dependencies"><a class="header" href="#missing-dependencies">Missing Dependencies</a></h3>
<p><strong>Problem</strong>: Compilation fails due to missing system libraries.</p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt install build-essential pkg-config libssl-dev

# CentOS/RHEL
sudo yum install gcc gcc-c++ openssl-devel pkgconfig
</code></pre>
<h3 id="rust-version-issues"><a class="header" href="#rust-version-issues">Rust Version Issues</a></h3>
<p><strong>Problem</strong>: Compilation fails due to incompatible Rust version.</p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-bash"># Update Rust
rustup update

# Check version (needs 1.76+)
rustc --version

# Set specific toolchain if needed
rustup default stable
</code></pre>
<h3 id="link-errors-on-older-systems"><a class="header" href="#link-errors-on-older-systems">Link Errors on Older Systems</a></h3>
<p><strong>Problem</strong>: Linking errors with glibc or other system libraries.</p>
<p><strong>Solution</strong>:
Use the musl build instead:</p>
<pre><code class="language-bash"># Install musl target
rustup target add x86_64-unknown-linux-musl

# Build with musl
cargo build --target x86_64-unknown-linux-musl --release
</code></pre>
<h2 id="configuration-issues"><a class="header" href="#configuration-issues">Configuration Issues</a></h2>
<h3 id="database-connection-failures"><a class="header" href="#database-connection-failures">Database Connection Failures</a></h3>
<p><strong>Problem</strong>: <code>FATAL: database "mitosis" does not exist</code></p>
<p><strong>Solution</strong>:</p>
<ol>
<li>
<p>Create the database:</p>
<pre><code class="language-sql">psql -U postgres -c "CREATE DATABASE mitosis;"
psql -U postgres -c "CREATE USER username WITH PASSWORD 'password';"
psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE mitosis TO useranme;"
</code></pre>
</li>
<li>
<p>Check connection string format:</p>
<pre><code class="language-toml">db_url = "postgres://username:password@host:port/mitosis"
</code></pre>
</li>
</ol>
<h3 id="s3-storage-connection-issues"><a class="header" href="#s3-storage-connection-issues">S3 Storage Connection Issues</a></h3>
<p><strong>Problem</strong>: S3 authentication or connection failures.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>
<p>Verify MinIO/S3 is running:</p>
<pre><code class="language-bash"># For MinIO
docker ps | grep minio
curl http://localhost:9000/minio/health/ready
</code></pre>
</li>
<li>
<p>Check credentials and bucket access:</p>
<pre><code class="language-bash"># Using AWS CLI to test
aws --endpoint-url=http://localhost:9000 s3 ls
</code></pre>
</li>
</ol>
<h3 id="redis-connection-problems"><a class="header" href="#redis-connection-problems">Redis Connection Problems</a></h3>
<p><strong>Problem</strong>: Redis connection refused or authentication failures.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>
<p>Check Redis status:</p>
<pre><code class="language-bash">redis-cli ping
# Should return PONG
</code></pre>
</li>
<li>
<p>Verify ACL rules (Redis 6.0+):</p>
<pre><code class="language-bash">redis-cli ACL LIST
redis-cli ACL DELUSER default  # If needed
</code></pre>
</li>
</ol>
<h3 id="ssl-key-generation-issues"><a class="header" href="#ssl-key-generation-issues">SSL Key Generation Issues</a></h3>
<p><strong>Problem</strong>: Ed25519 key generation fails or keys not recognized.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>
<p>Ensure OpenSSL version supports Ed25519 (1.1.1+):</p>
<pre><code class="language-bash">openssl version
</code></pre>
</li>
<li>
<p>Generate keys correctly:</p>
<pre><code class="language-bash">openssl genpkey -algorithm ed25519 -out private.pem
openssl pkey -in private.pem -pubout -out public.pem
</code></pre>
</li>
<li>
<p>Verify key format:</p>
<pre><code class="language-bash">openssl pkey -in private.pem -text -noout
</code></pre>
</li>
</ol>
<h2 id="network-issues"><a class="header" href="#network-issues">Network Issues</a></h2>
<h3 id="port-already-in-use"><a class="header" href="#port-already-in-use">Port Already in Use</a></h3>
<p><strong>Problem</strong>: <code>Address already in use</code> when starting coordinator.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>
<p>Find what's using the port:</p>
<pre><code class="language-bash">lsof -i :5000
netstat -tulpn | grep 5000
</code></pre>
</li>
<li>
<p>Change the port:</p>
<pre><code class="language-bash">mito coordinator --bind 0.0.0.0:5001
</code></pre>
</li>
</ol>
<h3 id="firewall-blocking-connections"><a class="header" href="#firewall-blocking-connections">Firewall Blocking Connections</a></h3>
<p><strong>Problem</strong>: Workers can't connect to coordinator.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>
<p>Check firewall rules:</p>
<pre><code class="language-bash"># Ubuntu
sudo ufw status
sudo ufw allow 5000

# CentOS/RHEL
sudo firewall-cmd --list-ports
sudo firewall-cmd --permanent --add-port=5000/tcp
sudo firewall-cmd --reload
</code></pre>
</li>
<li>
<p>Test connectivity:</p>
<pre><code class="language-bash">telnet coordinator_host 5000
curl http://coordinator_host:5000/health
</code></pre>
</li>
</ol>
<h2 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h2>
<h3 id="slow-task-execution"><a class="header" href="#slow-task-execution">Slow Task Execution</a></h3>
<p><strong>Problem</strong>: Tasks taking longer than expected to start or complete.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Reduce polling interval for workers:</p>
<pre><code class="language-toml">polling_interval = "30s"  # Faster polling
</code></pre>
</li>
<li>
<p>Increase worker parallelism:</p>
<pre><code class="language-bash"># Run multiple workers on the same node
mito worker &amp;
mito worker &amp;
</code></pre>
</li>
<li>
<p>Monitor database performance:</p>
<pre><code class="language-sql">SELECT * FROM pg_stat_activity;
SELECT * FROM pg_stat_user_tables;
</code></pre>
</li>
</ol>
<h3 id="database-lock-contention"><a class="header" href="#database-lock-contention">Database Lock Contention</a></h3>
<p><strong>Problem</strong>: High lock wait times or deadlocks.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>
<p>Monitor locks:</p>
<pre><code class="language-sql">SELECT * FROM pg_locks WHERE NOT granted;
</code></pre>
</li>
<li>
<p>Tune PostgreSQL settings:</p>
<pre><code class="language-postgresql">max_connections = 100
shared_buffers = 256MB
effective_cache_size = 1GB
</code></pre>
</li>
</ol>
<h2 id="debugging-tips"><a class="header" href="#debugging-tips">Debugging Tips</a></h2>
<h3 id="enable-debug-logging"><a class="header" href="#enable-debug-logging">Enable Debug Logging</a></h3>
<pre><code class="language-bash">RUST_LOG=debug mito coordinator
RUST_LOG=netmito=debug mito worker
RUST_LOG=debug mito client
</code></pre>
<h3 id="health-checks"><a class="header" href="#health-checks">Health Checks</a></h3>
<pre><code class="language-bash"># Check coordinator health
curl http://localhost:5000/health

# Check database connection
psql "postgres://mitosis:mitosis@localhost/mitosis" -c "SELECT version();"

# Check S3 connection
aws --endpoint-url=http://localhost:9000 s3 ls
</code></pre>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you continue to experience issues:</p>
<ol>
<li>
<p>Check the <a href="https://github.com/stack-rs/mitosis/issues">GitHub Issues</a> for similar problems</p>
</li>
<li>
<p>Run with debug logging and include logs in your issue report</p>
</li>
<li>
<p>Provide system information:</p>
<pre><code class="language-bash">mito --version
rustc --version
uname -a
docker --version  # if using Docker
</code></pre>
</li>
<li>
<p>Include relevant configuration (sanitize sensitive data)</p>
</li>
<li>
<p>Describe the expected vs actual behavior</p>
</li>
<li>
<p>List steps to reproduce the issue</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-sdk"><a class="header" href="#client-sdk">Client SDK</a></h1>
<p>The Mitosis project contains a SDK library (named <code>netmito</code>) that you can use to create your own client applications programmatically. The SDK provides a comprehensive Rust API for interacting with Mitosis coordinators.
For Python SDK, please refer to the <a href="https://github.com/stack-rs/mitosis-python-sdk">Mitosis Python SDK repository</a>.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
netmito = "0.6.5"
tokio = { version = "1.0", features = ["full"] }
uuid = { version = "1.18", features = ["v4"] }
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<h3 id="client-setup"><a class="header" href="#client-setup">Client Setup</a></h3>
<pre><code class="language-rust ignore">use netmito::client::MitoClient;
use netmito::config::{ClientConfig, client::LoginArgs};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create client configuration
    let mut config = ClientConfig::default();
    config.coordinator_addr = "http://localhost:5000".parse()?;

    // Create client instance
    let mut client = MitoClient::setup(config).await?;

    // Login with credentials
    let login_args = LoginArgs {
        username: Some("username".to_string()),
        password: Some("password".to_string()),
        retain: true,
    };
    client.user_login(login_args).await?;

    Ok(())
}</code></pre>
<h3 id="task-management"><a class="header" href="#task-management">Task Management</a></h3>
<h4 id="submitting-tasks"><a class="header" href="#submitting-tasks">Submitting Tasks</a></h4>
<pre><code class="language-rust ignore">use netmito::config::client::TaskSubmitArgs;

// Submit a simple task
let args = TaskSubmitArgs {
    command: vec!["echo".to_string(), "Hello World".to_string()],
    group: Some("my-group".to_string()),
    tags: vec!["test".to_string()],
    labels: vec!["example".to_string()],
    env: vec!["MY_VAR=value".to_string()],
    terminal: true, // Capture stdout/stderr
    ..Default::default()
};

let task_id = client.task_submit(args).await?;
println!("Submitted task: {}", task_id);</code></pre>
<h4 id="querying-tasks"><a class="header" href="#querying-tasks">Querying Tasks</a></h4>
<pre><code class="language-rust ignore">use netmito::config::client::TaskQueryArgs;

// Query all tasks
let args = TaskQueryArgs::default();
let tasks = client.task_query(args).await?;

// Query tasks with filters
let args = TaskQueryArgs {
    labels: Some(vec!["example".to_string()]),
    status: Some("completed".to_string()),
    limit: Some(10),
    ..Default::default()
};
let filtered_tasks = client.task_query(args).await?;</code></pre>
<h4 id="getting-task-details"><a class="header" href="#getting-task-details">Getting Task Details</a></h4>
<pre><code class="language-rust ignore">use uuid::Uuid;

let task_id = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000")?;
let task_info = client.task_get(task_id).await?;

println!("Task status: {:?}", task_info.exec_state);
println!("Created at: {}", task_info.created_at);</code></pre>
<h4 id="downloading-artifacts"><a class="header" href="#downloading-artifacts">Downloading Artifacts</a></h4>
<pre><code class="language-rust ignore">use netmito::config::client::TaskArtifactDownloadArgs;

let args = TaskArtifactDownloadArgs {
    task_id,
    artifact_type: "result".to_string(), // "result", "exec-log", or "std-log"
    output_path: Some("./task-results.tar.gz".to_string()),
    ..Default::default()
};

client.task_artifact_download(args).await?;</code></pre>
<h3 id="user-and-group-management"><a class="header" href="#user-and-group-management">User and Group Management</a></h3>
<h4 id="creating-users-admin-only"><a class="header" href="#creating-users-admin-only">Creating Users (Admin only)</a></h4>
<pre><code class="language-rust ignore">use netmito::config::client::AdminCreateUserArgs;

let args = AdminCreateUserArgs {
    username: Some("new_user".to_string()),
    password: Some("secure_password".to_string()),
    admin: false,
};

client.admin_create_user(args).await?;</code></pre>
<h4 id="group-operations"><a class="header" href="#group-operations">Group Operations</a></h4>
<pre><code class="language-rust ignore">use netmito::config::client::{GroupCreateArgs, GroupUpdateUserArgs};

// Create a group
let args = GroupCreateArgs {
    group_name: "research-team".to_string(),
};
client.group_create(args).await?;

// Add user to group
let args = GroupUpdateUserArgs {
    group_name: "research-team".to_string(),
    username: "researcher".to_string(),
    role: "write".to_string(), // "read", "write", or "admin"
};
client.group_update_user(args).await?;</code></pre>
<h3 id="worker-management"><a class="header" href="#worker-management">Worker Management</a></h3>
<h4 id="querying-workers"><a class="header" href="#querying-workers">Querying Workers</a></h4>
<pre><code class="language-rust ignore">use netmito::config::client::WorkerQueryArgs;

let args = WorkerQueryArgs {
    group: Some("my-group".to_string()),
    tags: Some(vec!["gpu".to_string()]),
    ..Default::default()
};

let workers = client.worker_query(args).await?;
for worker in workers {
    println!("Worker {} is {}", worker.id, worker.status);
}</code></pre>
<h4 id="managing-worker-tags"><a class="header" href="#managing-worker-tags">Managing Worker Tags</a></h4>
<pre><code class="language-rust ignore">use netmito::config::client::WorkerUpdateTagsArgs;

let worker_id = Uuid::parse_str("worker-uuid-here")?;
let args = WorkerUpdateTagsArgs {
    worker_id,
    tags: vec!["gpu".to_string(), "cuda".to_string()],
};

client.worker_update_tags(args).await?;</code></pre>
<h3 id="group-attachments"><a class="header" href="#group-attachments">Group Attachments</a></h3>
<h4 id="uploading-files"><a class="header" href="#uploading-files">Uploading Files</a></h4>
<pre><code class="language-rust ignore">use netmito::config::client::GroupAttachmentUploadArgs;

let args = GroupAttachmentUploadArgs {
    group_name: Some("my-group".to_string()),
    local_path: "./dataset.tar.gz".to_string(),
    attachment_key: Some("datasets/experiment-1.tar.gz".to_string()),
    ..Default::default()
};

client.group_attachment_upload(args).await?;</code></pre>
<h4 id="downloading-files"><a class="header" href="#downloading-files">Downloading Files</a></h4>
<pre><code class="language-rust ignore">use netmito::config::client::GroupAttachmentDownloadArgs;

let args = GroupAttachmentDownloadArgs {
    group_name: Some("my-group".to_string()),
    attachment_key: "datasets/experiment-1.tar.gz".to_string(),
    output_path: Some("./downloaded-dataset.tar.gz".to_string()),
    ..Default::default()
};

client.group_attachment_download(args).await?;</code></pre>
<h3 id="batch-operations-v065"><a class="header" href="#batch-operations-v065">Batch Operations (v0.6.5+)</a></h3>
<p>Starting from version 0.6.5, the SDK supports batch operations for improved efficiency when working with multiple resources:</p>
<h4 id="batch-task-submission"><a class="header" href="#batch-task-submission">Batch Task Submission</a></h4>
<p>Submit multiple tasks at once:</p>
<pre><code class="language-rust ignore">use netmito::config::client::TaskSubmitArgs;
use netmito::schema::BatchTaskSubmitReq;

let tasks = vec![
    TaskSubmitArgs {
        command: vec!["echo".to_string(), "task1".to_string()],
        group: Some("my-group".to_string()),
        ..Default::default()
    },
    TaskSubmitArgs {
        command: vec!["echo".to_string(), "task2".to_string()],
        group: Some("my-group".to_string()),
        ..Default::default()
    },
];

let batch_req = BatchTaskSubmitReq { tasks };
let task_ids = client.batch_submit_tasks(batch_req).await?;</code></pre>
<h4 id="batch-task-cancellation"><a class="header" href="#batch-task-cancellation">Batch Task Cancellation</a></h4>
<p>Cancel multiple tasks by UUID or by filter:</p>
<pre><code class="language-rust ignore">use uuid::Uuid;
use netmito::schema::BatchCancelByUuidsReq;

// Cancel by specific UUIDs
let task_ids = vec![
    Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000")?,
    Uuid::parse_str("660e8400-e29b-41d4-a716-446655440001")?,
];
let req = BatchCancelByUuidsReq { uuids: task_ids };
client.tasks_batch_cancel_by_uuids(req).await?;

// Or cancel by filter
use netmito::config::client::TaskQueryArgs;
let filter = TaskQueryArgs {
    labels: Some(vec!["test".to_string()]),
    status: Some("pending".to_string()),
    ..Default::default()
};
client.tasks_batch_cancel(filter).await?;</code></pre>
<h4 id="batch-artifact-download"><a class="header" href="#batch-artifact-download">Batch Artifact Download</a></h4>
<p>Download multiple artifacts at once:</p>
<pre><code class="language-rust ignore">use netmito::config::client::{TaskQueryArgs, TaskArtifactDownloadArgs};

// Download artifacts by filter
let filter = TaskQueryArgs {
    labels: Some(vec!["experiment-1".to_string()]),
    status: Some("completed".to_string()),
    ..Default::default()
};
let download_args = TaskArtifactDownloadArgs {
    artifact_type: "result".to_string(),
    output_path: Some("./results/".to_string()),
    ..Default::default()
};
client.batch_download_artifacts_by_filter(filter, download_args).await?;

// Or download specific artifacts by task IDs
use netmito::schema::BatchDownloadArtifactsByListReq;
let req = BatchDownloadArtifactsByListReq {
    task_ids: vec![task_id1, task_id2],
    artifact_type: "result".to_string(),
};
client.batch_download_artifacts_by_list(req, "./results/".to_string()).await?;</code></pre>
<h4 id="batch-attachment-operations"><a class="header" href="#batch-attachment-operations">Batch Attachment Operations</a></h4>
<p>Download or delete multiple group attachments:</p>
<pre><code class="language-rust ignore">use netmito::config::client::GroupAttachmentQueryArgs;
use netmito::schema::BatchDownloadAttachmentsByListReq;

// Download attachments by filter
let filter = GroupAttachmentQueryArgs {
    group_name: Some("my-group".to_string()),
    key: Some("datasets/".to_string()), // prefix matching
    ..Default::default()
};
client.batch_download_attachments_by_filter(filter, "./downloads/".to_string()).await?;

// Delete attachments by list
let keys = vec!["old-data-1.tar.gz".to_string(), "old-data-2.tar.gz".to_string()];
let req = BatchDownloadAttachmentsByListReq {
    group_name: "my-group".to_string(),
    keys,
};
client.batch_delete_attachments_by_list(req).await?;</code></pre>
<h4 id="batch-worker-cancellation"><a class="header" href="#batch-worker-cancellation">Batch Worker Cancellation</a></h4>
<p>Cancel multiple workers at once:</p>
<pre><code class="language-rust ignore">use netmito::schema::BatchCancelByUuidsReq;

// Cancel workers by UUIDs
let worker_ids = vec![worker_uuid1, worker_uuid2];
let req = BatchCancelByUuidsReq { uuids: worker_ids };
client.workers_batch_cancel_by_uuids(req).await?;

// Or cancel by filter
use netmito::config::client::WorkerQueryArgs;
let filter = WorkerQueryArgs {
    tags: Some(vec!["deprecated".to_string()]),
    ..Default::default()
};
client.workers_batch_cancel(filter).await?;</code></pre>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<pre><code class="language-rust ignore">use netmito::config::ClientConfig;
use url::Url;
use figment::value::magic::RelativePathBuf;

let config = ClientConfig {
    coordinator_addr: Url::parse("https://coordinator.example.com")?,
    credential_path: Some(RelativePathBuf::from("/path/to/credentials")),
    user: Some("api-user".to_string()),
    password: Some("api-password".to_string()),
    retain: true, // Keep existing login state
};</code></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<pre><code class="language-rust ignore">use netmito::error::{Error, ApiError, AuthError};

match client.task_get(task_id).await {
    Ok(task) =&gt; println!("Task found: {:?}", task),
    Err(Error::ApiError(ApiError::NotFound(_))) =&gt; println!("Task not found"),
    Err(Error::ApiError(ApiError::AuthError(AuthError::PermissionDenied))) =&gt; println!("Access denied"),
    Err(e) =&gt; println!("Other error: {}", e),
}</code></pre>
<h3 id="async-patterns"><a class="header" href="#async-patterns">Async Patterns</a></h3>
<pre><code class="language-rust ignore">use futures::future::join_all;

// Submit multiple tasks concurrently
let tasks: Vec&lt;_&gt; = (0..10).map(|i| {
    let mut client = client.clone();
    let args = TaskSubmitArgs {
        command: vec!["sleep".to_string(), i.to_string()],
        ..Default::default()
    };
    async move { client.task_submit(args).await }
}).collect();

let results = join_all(tasks).await;
for result in results {
    match result {
        Ok(task_id) =&gt; println!("Submitted: {}", task_id),
        Err(e) =&gt; println!("Failed: {}", e),
    }
}</code></pre>
<h3 id="real-time-task-monitoring"><a class="header" href="#real-time-task-monitoring">Real-time Task Monitoring</a></h3>
<pre><code class="language-rust ignore">use netmito::client::redis::MitoRedisClient;
use netmito::entity::state::TaskExecState;
use tokio::time::{interval, Duration};

// Set up Redis client for real-time updates
let mut redis_client = client.get_redis_client().await?;

// Poll task status periodically
let mut interval = interval(Duration::from_secs(5));
loop {
    interval.tick().await;

    let task = client.task_get(task_id).await?;
    println!("Task status: {:?}", task.exec_state);

    if matches!(task.exec_state, TaskExecState::Completed | TaskExecState::Failed) {
        break;
    }
}</code></pre>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="cicd-pipeline-integration"><a class="header" href="#cicd-pipeline-integration">CI/CD Pipeline Integration</a></h3>
<pre><code class="language-rust ignore">pub struct MitosisPipeline {
    client: MitoClient,
}

impl MitosisPipeline {
    pub async fn run_test_suite(&amp;mut self, commit_hash: &amp;str) -&gt; Result&lt;bool, Box&lt;dyn std::error::Error&gt;&gt; {
        // Submit test tasks
        let test_args = TaskSubmitArgs {
            command: vec!["cargo".to_string(), "test".to_string(), "--release".to_string()],
            group: Some("ci-runners".to_string()),
            tags: vec!["rust".to_string(), "testing".to_string()],
            labels: vec![format!("commit:{}", commit_hash)],
            terminal: true,
            ..Default::default()
        };

        let task_id = self.client.task_submit(test_args).await?;

        // Wait for completion
        let result = self.wait_for_task(task_id).await?;

        // Download test results
        let artifact_args = TaskArtifactDownloadArgs {
            task_id,
            artifact_type: "std-log".to_string(),
            output_path: Some(format!("test-results-{}.tar.gz", commit_hash)),
            ..Default::default()
        };

        self.client.task_artifact_download(artifact_args).await?;

        Ok(result.exec_state == TaskExecState::Completed)
    }
}</code></pre>
<h3 id="research-computing-workflow"><a class="header" href="#research-computing-workflow">Research Computing Workflow</a></h3>
<pre><code class="language-rust ignore">pub struct ResearchWorkflow {
    client: MitoClient,
    group: String,
}

impl ResearchWorkflow {
    pub async fn run_parameter_sweep(&amp;mut self, parameters: Vec&lt;Vec&lt;String&gt;&gt;) -&gt; Result&lt;Vec&lt;Uuid&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let mut task_ids = Vec::new();

        for (i, params) in parameters.into_iter().enumerate() {
            let args = TaskSubmitArgs {
                command: vec!["python3".to_string(), "experiment.py".to_string()],
                env: params.into_iter().map(|p| format!("PARAM_{}", p)).collect(),
                group: Some(self.group.clone()),
                labels: vec![format!("sweep:experiment-{}", i)],
                tags: vec!["gpu".to_string(), "python".to_string()],
                terminal: true,
                ..Default::default()
            };

            let task_id = self.client.task_submit(args).await?;
            task_ids.push(task_id);
        }

        Ok(task_ids)
    }

    pub async fn collect_results(&amp;mut self, task_ids: Vec&lt;Uuid&gt;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        for task_id in task_ids {
            let args = TaskArtifactDownloadArgs {
                task_id,
                artifact_type: "result".to_string(),
                output_path: Some(format!("results/{}.tar.gz", task_id)),
                ..Default::default()
            };

            self.client.task_artifact_download(args).await?;
        }

        Ok(())
    }
}</code></pre>
<h2 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h2>
<p>For complete API documentation, including all available methods, configuration options, and error types, please refer to the <a href="https://docs.rs/netmito">API documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-endpoints"><a class="header" href="#http-endpoints">HTTP endpoints</a></h1>
<p>We have provide users and developers with an OpenAPI specification of our http endpoints. You can find it in the root of our repository (<a href="https://github.com/stack-rs/mitosis/blob/main/openapi.yaml">openapi.yaml</a>) or access it online <a href="https://raw.githubusercontent.com/stack-rs/mitosis/refs/heads/main/openapi.yaml">herer with raw format</a>.</p>
<p>You can just read the specification file to understand how to interact with our http endpoints, or you can use tools like <a href="https://swagger.io/tools/swagger-ui/">Swagger UI</a> or the online <a href="https://editor.swagger.io/">Swagger Editor</a> to interactively explore and test the API.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
